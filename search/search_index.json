{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the knead documentation, and happy baking! How to read this documentation I have font files, and want to do some deep learning. Check out the quickstart for installation and usage instructions. I want to learn how knead works. Check out the user guide for details about knead 's internals. I want to contribute to knead . Check out the developer guide for technical information on the various data formats that knead supports, and the contributing guide for details on how to make a contribution.","title":"Home"},{"location":"#how-to-read-this-documentation","text":"I have font files, and want to do some deep learning. Check out the quickstart for installation and usage instructions. I want to learn how knead works. Check out the user guide for details about knead 's internals. I want to contribute to knead . Check out the developer guide for technical information on the various data formats that knead supports, and the contributing guide for details on how to make a contribution.","title":"How to read this documentation"},{"location":"contributing/","text":"Contributing Guide Happy baking! Set up development environment git clone https://github.com/font-bakers/knead.git cd knead/ make develop source venv/bin/activate # Do your work... deactivate Before committing make check This will both lint the knead/ directory (with black and pylint ), and run test scripts. You may lint and test separately with make lint and make test , respectively. Make sure that all checks pass before committing: you should get several blue success messages as each check passes. Note that knead uses a pre-commit git hook to format staged Python files in-place using black . Packaging and releasing knead First, ensure that the version number has been bumped appropriately: knead adopts the Semantic Versioning 2.0.0 specification. This can be done either by running bumpversion --current-version CURRENT_VERSION PART knead/__init__.py or by directly editing the __version__ variable in knead/__init__.py (the latter method is simpler and recommended for such a simple project as knead ). For more information, see the bumpversion documentation . Then, run make package . It will package knead and validate the resulting source archive and built distribution . Finally, upload the source archive and build distribution to PyPI. You will be asked for a username and password for PyPI. twine upload dist/* For more information, refer to the Python packaging documentation . Miscellaneous development details knead adopts the Semantic Versioning 2.0.0 specification. knead targets Python 3.5+ (specifically, 3.5.2+) compatibility. knead uses black and pylint to format and lint code, respectively. However, black requires Python 3.6+ to run. Thus, we test in Python 3.5 but lint in Python 3.6. See our Travis configuration for more details. knead contains integration tests in the form of the test.sh script . knead is currently not unit tested. Briefly, test.sh first hashes the data/ directory (using the shasum command line tool). It then runs the entire data pipeline, conversion by conversion, on one font ( Georgia.ttf ). After every conversion, the data/ directory is hashed again. If the hash differs from the initial hash, the test fails. In this way, we test the knead output for correctness. This is not possible for .pb files, which change after every write. Thus, we merely count the number of .pb files that are generated. The knead documentation is generated using mkdocs . See the mkdocs.yml configuration for more details.","title":"Contributing"},{"location":"contributing/#contributing-guide","text":"Happy baking!","title":"Contributing Guide"},{"location":"contributing/#set-up-development-environment","text":"git clone https://github.com/font-bakers/knead.git cd knead/ make develop source venv/bin/activate # Do your work... deactivate","title":"Set up development environment"},{"location":"contributing/#before-committing","text":"make check This will both lint the knead/ directory (with black and pylint ), and run test scripts. You may lint and test separately with make lint and make test , respectively. Make sure that all checks pass before committing: you should get several blue success messages as each check passes. Note that knead uses a pre-commit git hook to format staged Python files in-place using black .","title":"Before committing"},{"location":"contributing/#packaging-and-releasing-knead","text":"First, ensure that the version number has been bumped appropriately: knead adopts the Semantic Versioning 2.0.0 specification. This can be done either by running bumpversion --current-version CURRENT_VERSION PART knead/__init__.py or by directly editing the __version__ variable in knead/__init__.py (the latter method is simpler and recommended for such a simple project as knead ). For more information, see the bumpversion documentation . Then, run make package . It will package knead and validate the resulting source archive and built distribution . Finally, upload the source archive and build distribution to PyPI. You will be asked for a username and password for PyPI. twine upload dist/* For more information, refer to the Python packaging documentation .","title":"Packaging and releasing knead"},{"location":"contributing/#miscellaneous-development-details","text":"knead adopts the Semantic Versioning 2.0.0 specification. knead targets Python 3.5+ (specifically, 3.5.2+) compatibility. knead uses black and pylint to format and lint code, respectively. However, black requires Python 3.6+ to run. Thus, we test in Python 3.5 but lint in Python 3.6. See our Travis configuration for more details. knead contains integration tests in the form of the test.sh script . knead is currently not unit tested. Briefly, test.sh first hashes the data/ directory (using the shasum command line tool). It then runs the entire data pipeline, conversion by conversion, on one font ( Georgia.ttf ). After every conversion, the data/ directory is hashed again. If the hash differs from the initial hash, the test fails. In this way, we test the knead output for correctness. This is not possible for .pb files, which change after every write. Thus, we merely count the number of .pb files that are generated. The knead documentation is generated using mkdocs . See the mkdocs.yml configuration for more details.","title":"Miscellaneous development details"},{"location":"developer-guide/","text":"Developer Guide The TrueType standard and the .ttx file format Briefly, the TrueType font standard encodes all of the information discussed in the user guide . The .ttx file format is simply an XML file that encodes a font, specified by fonttools . In a .ttx file, each glyph is contained within a <ttGlyph> tag. This tag has several <contour> definitions. Within each contour we have successive <pt> tags which define control points. Each control point specifies its location (i.e., x and y coordinates) and whether the point is \"on curve\" or \"off curve\". There are some important rules on how to understand these points. If two successive points are \"on\" this means that they form a line. If three points are \"on\", \"off\", \"on\" then this defines a quadratic Bezier curve. If there are several \"off\" points with no \"on\" point in between them, there is a virtual \"on\" point in the middle of the two \"off\" points. This is a form of data compression. If the first point in a contour is an \"off\" point go to the last point and start from there. If the last point is also \"off\" start with a virtual \"on\" in between the first and the last one. For more information, refer to: The fonttools documentation . Glyph Hell by David Turner The FreeType Glyph Conventions documentation This StackOverflow thread on parsing .ttf files Protocol buffers (protobufs) In the words of the Google documentation , protocol buffers are a language-neutral, platform-neutral, extensible way of serializing structured data for use in communications protocols, data storage, and more. For more information on protobufs, please refer to the protobuf developer guide , and the protobuf tutorial for Python . Here, we describe how knead uses protobufs. The glyph_batch.proto file specifies the protobuf for a batch of glyphs, and the glyph_batch_pb2.py is the corresponding output of the protobuf compiler . To compile a glyph_batch.proto file to a Python file, you will need to install the protobuf compiler ( protoc ). See the protobuf compiler installtion instructions . Then, run the following command from the project root directory: protoc --proto_path=knead/utils/ --python_out=knead/utils/ knead/utils/glyph_batch.proto Miscellaneous notes Since knead relies heavily on fonttools (specifically, the ttx command line tool) to convert .ttf files to .ttx , correct and reproducible behavior is contingent on having the correct version of fonttools . Therefore, the fonttools version number is pinned in knead 's requirements.txt .","title":"Developer Guide"},{"location":"developer-guide/#developer-guide","text":"","title":"Developer Guide"},{"location":"developer-guide/#the-truetype-standard-and-the-ttx-file-format","text":"Briefly, the TrueType font standard encodes all of the information discussed in the user guide . The .ttx file format is simply an XML file that encodes a font, specified by fonttools . In a .ttx file, each glyph is contained within a <ttGlyph> tag. This tag has several <contour> definitions. Within each contour we have successive <pt> tags which define control points. Each control point specifies its location (i.e., x and y coordinates) and whether the point is \"on curve\" or \"off curve\". There are some important rules on how to understand these points. If two successive points are \"on\" this means that they form a line. If three points are \"on\", \"off\", \"on\" then this defines a quadratic Bezier curve. If there are several \"off\" points with no \"on\" point in between them, there is a virtual \"on\" point in the middle of the two \"off\" points. This is a form of data compression. If the first point in a contour is an \"off\" point go to the last point and start from there. If the last point is also \"off\" start with a virtual \"on\" in between the first and the last one. For more information, refer to: The fonttools documentation . Glyph Hell by David Turner The FreeType Glyph Conventions documentation This StackOverflow thread on parsing .ttf files","title":"The TrueType standard and the .ttx file format"},{"location":"developer-guide/#protocol-buffers-protobufs","text":"In the words of the Google documentation , protocol buffers are a language-neutral, platform-neutral, extensible way of serializing structured data for use in communications protocols, data storage, and more. For more information on protobufs, please refer to the protobuf developer guide , and the protobuf tutorial for Python . Here, we describe how knead uses protobufs. The glyph_batch.proto file specifies the protobuf for a batch of glyphs, and the glyph_batch_pb2.py is the corresponding output of the protobuf compiler . To compile a glyph_batch.proto file to a Python file, you will need to install the protobuf compiler ( protoc ). See the protobuf compiler installtion instructions . Then, run the following command from the project root directory: protoc --proto_path=knead/utils/ --python_out=knead/utils/ knead/utils/glyph_batch.proto","title":"Protocol buffers (protobufs)"},{"location":"developer-guide/#miscellaneous-notes","text":"Since knead relies heavily on fonttools (specifically, the ttx command line tool) to convert .ttf files to .ttx , correct and reproducible behavior is contingent on having the correct version of fonttools . Therefore, the fonttools version number is pinned in knead 's requirements.txt .","title":"Miscellaneous notes"},{"location":"quickstart/","text":"Quickstart For more information on how knead works, refer to the user guide . Installation The latest release of knead can be installed from PyPI: pip install knead The bleeding edge development branch of knead can be installed from GitHub: pip install git+https://github.com/font-bakers/knead.git Usage On the command line: knead --input INPUT_FORMAT --output OUTPUT_FORMAT --directory PATH/TO/DATA/ The --input and --output flags must be one of: ttf : a .ttf font file. ttx : a .ttx XML format of the font. For more details, refer to the fonttools documentation . json : a .json format of the font. pb : a .pb serialized protobuf format of each glyph in each font. npy : a .npy format of samples from quadratic Bezier curves in each glyph in each font. The --directory must have the following structure: data \u2514\u2500\u2500 ttf \u251c\u2500\u2500 Georgia.ttf \u2514\u2500\u2500 ... In other words, --directory is not the directory containing the .ttf files. It is a directory that contains a subdirectory (called ttf ) containing the .ttf files. It is recommended that users organize their data similarly: that is, each directory contains only subdirectories with the same data in various different data formats. In this way, each directory can be semantically associated with a single data set, irrespective of its data format. As knead does each conversion, a new subdirectory will be made in data/ , each with the corresponding file extension.Ultimately, after .ttf files are completely converted and sampled to .npy files, the data/ directory will have the following structure: data \u251c\u2500\u2500 json \u2502 \u251c\u2500\u2500 Georgia.json \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 npy_with_640_samples \u2502 \u251c\u2500\u2500 Georgia.A_upper.npy \u2502 \u251c\u2500\u2500 Georgia.B_upper.npy \u2502 \u251c\u2500\u2500 Georgia.C_upper.npy \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 pb \u2502 \u251c\u2500\u2500 Georgia.A_upper.pb \u2502 \u251c\u2500\u2500 Georgia.B_upper.pb \u2502 \u251c\u2500\u2500 Georgia.C_upper.pb \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 ttf \u2502 \u251c\u2500\u2500 Georgia.ttf \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 ttx \u251c\u2500\u2500 Georgia.ttx \u2514\u2500\u2500 ... In the event of a fatal error during the data preprocessing, knead will simply catch the exception and write the error message (along with a stack trace) to a knead.log file. Optional Flags Optional flags only matter if certain values are passed for the required flags (e.g. if --output npy is passed), and always default to some value. --normalize : Whether or not to normalize the x and y coordinates of the control points by the em box size. Pass --normalize to set to True, and pass --nonormalize to set to False. Defaults to True. Only relevant if --output json is passed. --num_samples : The number of samples to evaluate per quadratic Bezier curve. Defaults to 640. Only relevant if --output npy is passed. --max_num_points_in_contour : The maximum allowable number of control points per contour. Any glyphs containing contours with more than this number of control points will raise a RuntimeError upon conversion. Defaults to 60. Only relevant if --output npy is passed.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"For more information on how knead works, refer to the user guide .","title":"Quickstart"},{"location":"quickstart/#installation","text":"The latest release of knead can be installed from PyPI: pip install knead The bleeding edge development branch of knead can be installed from GitHub: pip install git+https://github.com/font-bakers/knead.git","title":"Installation"},{"location":"quickstart/#usage","text":"On the command line: knead --input INPUT_FORMAT --output OUTPUT_FORMAT --directory PATH/TO/DATA/ The --input and --output flags must be one of: ttf : a .ttf font file. ttx : a .ttx XML format of the font. For more details, refer to the fonttools documentation . json : a .json format of the font. pb : a .pb serialized protobuf format of each glyph in each font. npy : a .npy format of samples from quadratic Bezier curves in each glyph in each font. The --directory must have the following structure: data \u2514\u2500\u2500 ttf \u251c\u2500\u2500 Georgia.ttf \u2514\u2500\u2500 ... In other words, --directory is not the directory containing the .ttf files. It is a directory that contains a subdirectory (called ttf ) containing the .ttf files. It is recommended that users organize their data similarly: that is, each directory contains only subdirectories with the same data in various different data formats. In this way, each directory can be semantically associated with a single data set, irrespective of its data format. As knead does each conversion, a new subdirectory will be made in data/ , each with the corresponding file extension.Ultimately, after .ttf files are completely converted and sampled to .npy files, the data/ directory will have the following structure: data \u251c\u2500\u2500 json \u2502 \u251c\u2500\u2500 Georgia.json \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 npy_with_640_samples \u2502 \u251c\u2500\u2500 Georgia.A_upper.npy \u2502 \u251c\u2500\u2500 Georgia.B_upper.npy \u2502 \u251c\u2500\u2500 Georgia.C_upper.npy \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 pb \u2502 \u251c\u2500\u2500 Georgia.A_upper.pb \u2502 \u251c\u2500\u2500 Georgia.B_upper.pb \u2502 \u251c\u2500\u2500 Georgia.C_upper.pb \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 ttf \u2502 \u251c\u2500\u2500 Georgia.ttf \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 ttx \u251c\u2500\u2500 Georgia.ttx \u2514\u2500\u2500 ... In the event of a fatal error during the data preprocessing, knead will simply catch the exception and write the error message (along with a stack trace) to a knead.log file.","title":"Usage"},{"location":"quickstart/#optional-flags","text":"Optional flags only matter if certain values are passed for the required flags (e.g. if --output npy is passed), and always default to some value. --normalize : Whether or not to normalize the x and y coordinates of the control points by the em box size. Pass --normalize to set to True, and pass --nonormalize to set to False. Defaults to True. Only relevant if --output json is passed. --num_samples : The number of samples to evaluate per quadratic Bezier curve. Defaults to 640. Only relevant if --output npy is passed. --max_num_points_in_contour : The maximum allowable number of control points per contour. Any glyphs containing contours with more than this number of control points will raise a RuntimeError upon conversion. Defaults to 60. Only relevant if --output npy is passed.","title":"Optional Flags"},{"location":"user-guide/","text":"User Guide For technical details on various data formats, refer to the developer guide . Glyphs, contours and Bezier curves Before explaining knead 's internals, it is necessary to introduce how vector typefaces are represented. A typeface is composed of one or more fonts. A font is composed of several glyphs. A glyph is composed of one or more (closed) contours. A contour is composed of several Bezier curves . Quadratic Bezier curves are by far the most common. A (quadratic) Bezier curve is composed of exactly three control points. A control point is composed of an x and a y coordinate. The following image illustrates all these concepts. The ampersand is composed of three contours (one outer contour and two more for each counter space). Each contour is red, and is composed of several Bezier curves. Each Bezier curve is given by a black-grey-black sequence of points, denoting the on-off-on curve control points. (Note that the linear interpolations of each pair of control points is not the same as the Bezier curve, which is an interpolation of the interpolations). The knead data pipeline Under the hood, the data conversion pipeline looks like this: ---------- ---------- ----------- --------- ---------- | .ttf | --> | .ttx | --> | .json | --> | .pb | --> | .npy | ---------- ---------- ----------- --------- ---------- Each conversion between two data formats is explained in a different section below. .ttf to .ttx This conversion is handled by the fonttools ttx command line utility. For more information, refer to the fonttools documentation . Running knead --input ttf --output ttx MyFont.ttf is essentially a thin callthrough to ttx -q -o MyFont.ttx MyFont.ttf . Refer to the developer guide for more information on the .ttf and .ttx file formats. .ttx to .json This is done in Python, using the xml library, and following all the TrueType rules described above. The JSON object is structured as a dictionary, keyed by the character (e.g. \"A\" or \"exclam\" ), and valued by quadruply-nested lists. The four layers of nesting are best explained by code: with open(\"MyFont.json\", \"r\") as f: font = json.read(f) glyph = font[\"A\"] assert len(glyph) == num_contours_in_glyph contour = glyph[0] assert len(contour) == num_beziers_in_contour bezier = glyph[0] assert len(bezier) == 3 # Number of control points in a quadratic Bezier curve control_point = bezier[0] assert len(control_point) = 2 # x and y coordinates .json to .pb This is done in Python, using the protobuf library. Refer to the developer guide for more information on what protocol buffers are and how knead uses them. Note that .pb files are saved with _upper and _lower since some file systems do not distinguish between uppercase and lowercase filenames. .pb to .npy This is done in Python, using the numpy library. Note that unlike all other conversions, a single .pb file can be converted to several .npy files (e.g. by changing the number of samples per Bezier curve via --num_samples , etc.) Miscellaneous notes It is possible to run the data pipeline in reverse: e.g. we can convert .ttx files back to .ttf files, and it is theoretically possible to convert .json files back into .ttx files, etc. This is currently not a development priority. .ttf is the only font file format currently supported: in particular, .otf files are not supported.","title":"User Guide"},{"location":"user-guide/#user-guide","text":"For technical details on various data formats, refer to the developer guide .","title":"User Guide"},{"location":"user-guide/#glyphs-contours-and-bezier-curves","text":"Before explaining knead 's internals, it is necessary to introduce how vector typefaces are represented. A typeface is composed of one or more fonts. A font is composed of several glyphs. A glyph is composed of one or more (closed) contours. A contour is composed of several Bezier curves . Quadratic Bezier curves are by far the most common. A (quadratic) Bezier curve is composed of exactly three control points. A control point is composed of an x and a y coordinate. The following image illustrates all these concepts. The ampersand is composed of three contours (one outer contour and two more for each counter space). Each contour is red, and is composed of several Bezier curves. Each Bezier curve is given by a black-grey-black sequence of points, denoting the on-off-on curve control points. (Note that the linear interpolations of each pair of control points is not the same as the Bezier curve, which is an interpolation of the interpolations).","title":"Glyphs, contours and Bezier curves"},{"location":"user-guide/#the-knead-data-pipeline","text":"Under the hood, the data conversion pipeline looks like this: ---------- ---------- ----------- --------- ---------- | .ttf | --> | .ttx | --> | .json | --> | .pb | --> | .npy | ---------- ---------- ----------- --------- ---------- Each conversion between two data formats is explained in a different section below.","title":"The knead data pipeline"},{"location":"user-guide/#ttf-to-ttx","text":"This conversion is handled by the fonttools ttx command line utility. For more information, refer to the fonttools documentation . Running knead --input ttf --output ttx MyFont.ttf is essentially a thin callthrough to ttx -q -o MyFont.ttx MyFont.ttf . Refer to the developer guide for more information on the .ttf and .ttx file formats.","title":".ttf to .ttx"},{"location":"user-guide/#ttx-to-json","text":"This is done in Python, using the xml library, and following all the TrueType rules described above. The JSON object is structured as a dictionary, keyed by the character (e.g. \"A\" or \"exclam\" ), and valued by quadruply-nested lists. The four layers of nesting are best explained by code: with open(\"MyFont.json\", \"r\") as f: font = json.read(f) glyph = font[\"A\"] assert len(glyph) == num_contours_in_glyph contour = glyph[0] assert len(contour) == num_beziers_in_contour bezier = glyph[0] assert len(bezier) == 3 # Number of control points in a quadratic Bezier curve control_point = bezier[0] assert len(control_point) = 2 # x and y coordinates","title":".ttx to .json"},{"location":"user-guide/#json-to-pb","text":"This is done in Python, using the protobuf library. Refer to the developer guide for more information on what protocol buffers are and how knead uses them. Note that .pb files are saved with _upper and _lower since some file systems do not distinguish between uppercase and lowercase filenames.","title":".json to .pb"},{"location":"user-guide/#pb-to-npy","text":"This is done in Python, using the numpy library. Note that unlike all other conversions, a single .pb file can be converted to several .npy files (e.g. by changing the number of samples per Bezier curve via --num_samples , etc.)","title":".pb to .npy"},{"location":"user-guide/#miscellaneous-notes","text":"It is possible to run the data pipeline in reverse: e.g. we can convert .ttx files back to .ttf files, and it is theoretically possible to convert .json files back into .ttx files, etc. This is currently not a development priority. .ttf is the only font file format currently supported: in particular, .otf files are not supported.","title":"Miscellaneous notes"}]}